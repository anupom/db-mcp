const fs = require('fs');
const path = require('path');

/**
 * Multi-tenant Cube.js configuration
 *
 * This configuration supports multiple databases via securityContext.
 * The databaseId is passed via JWT from the MCP server.
 */
module.exports = {
  /**
   * Schema version for cache invalidation
   * Cube.js calls this per request. When the returned string changes,
   * schemas are recompiled without needing a container restart.
   * In dev mode, Cube.js also MD5-hashes files per request, but this
   * ensures reloading works in production mode too.
   */
  schemaVersion: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';
    const schemaDir = path.resolve(
      '/cube/data/databases', databaseId, 'cube', 'model', 'cubes'
    );
    try {
      // Use max mtime across all files (not dir mtime, which doesn't
      // change when existing files are edited on most filesystems)
      const files = fs.readdirSync(schemaDir);
      let maxMtime = 0;
      for (const file of files) {
        if (file.endsWith('.yml') || file.endsWith('.yaml') || file.endsWith('.js')) {
          const stat = fs.statSync(path.join(schemaDir, file));
          if (stat.mtimeMs > maxMtime) maxMtime = stat.mtimeMs;
        }
      }
      return `${databaseId}_${maxMtime}`;
    } catch {
      return `${databaseId}_0`;
    }
  },


  /**
   * Dynamic driver factory for multi-tenant database connections
   * Reads connection info from exported JSON file generated by MCP server
   * Returns a driver instance for the specified database
   * Supports: postgres, mysql, redshift, bigquery, snowflake, clickhouse
   */
  driverFactory: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';
    const connectionsPath = path.resolve('/cube/data/cube-connections.json');

    console.log(`[driverFactory] ========================================`);
    console.log(`[driverFactory] Request for databaseId: "${databaseId}"`);
    console.log(`[driverFactory] securityContext:`, JSON.stringify(securityContext || {}));

    // Check if connections file exists
    if (!fs.existsSync(connectionsPath)) {
      console.warn(`[driverFactory] WARNING: No connections file at ${connectionsPath}`);
      console.warn(`[driverFactory] Falling back to default driver from environment`);
      return undefined; // Use default from environment
    }

    try {
      const connections = JSON.parse(fs.readFileSync(connectionsPath, 'utf8'));
      const availableDatabases = Object.keys(connections);
      console.log(`[driverFactory] Available databases in connections file: [${availableDatabases.join(', ')}]`);

      const conn = connections[databaseId];

      if (!conn) {
        console.warn(`[driverFactory] WARNING: No connection config for "${databaseId}"`);
        console.warn(`[driverFactory] Available: [${availableDatabases.join(', ')}]`);
        console.warn(`[driverFactory] Falling back to default driver`);
        return undefined;
      }

      const dbType = conn.type || 'postgres';
      console.log(`[driverFactory] Creating ${dbType} driver for ${databaseId}`);

      // Create appropriate driver based on database type
      switch (dbType) {
        case 'postgres':
        case 'redshift': {
          // Redshift uses postgres driver (Redshift is Postgres-compatible)
          const PostgresDriver = require('@cubejs-backend/postgres-driver');
          return new PostgresDriver({
            host: conn.host,
            port: conn.port || (dbType === 'redshift' ? 5439 : 5432),
            database: conn.database,
            user: conn.user,
            password: conn.password,
            ssl: conn.ssl ? { rejectUnauthorized: false } : false,
          });
        }

        case 'mysql': {
          const MySqlDriver = require('@cubejs-backend/mysql-driver');
          return new MySqlDriver({
            host: conn.host,
            port: conn.port || 3306,
            database: conn.database,
            user: conn.user,
            password: conn.password,
            ssl: conn.ssl ? { rejectUnauthorized: false } : undefined,
          });
        }

        case 'bigquery': {
          const BigQueryDriver = require('@cubejs-backend/bigquery-driver');
          return new BigQueryDriver({
            projectId: conn.projectId,
            // Credentials can be JSON string or file path
            credentials: conn.options?.credentials,
            keyFilename: conn.options?.keyFilename,
            location: conn.options?.location,
          });
        }

        case 'snowflake': {
          const SnowflakeDriver = require('@cubejs-backend/snowflake-driver');
          return new SnowflakeDriver({
            account: conn.account,
            warehouse: conn.warehouse,
            database: conn.database,
            username: conn.user,
            password: conn.password,
            role: conn.options?.role,
            region: conn.options?.region,
          });
        }

        case 'clickhouse': {
          const ClickHouseDriver = require('@cubejs-backend/clickhouse-driver');
          return new ClickHouseDriver({
            host: conn.host,
            port: conn.port || 8123,
            database: conn.database,
            username: conn.user,
            password: conn.password,
          });
        }

        default:
          console.error(`[driverFactory] Unsupported database type: ${dbType}`);
          return undefined;
      }
    } catch (err) {
      console.error(`[driverFactory] Error:`, err.message);
      return undefined;
    }
  },

  /**
   * Map each database to its own app context for cache isolation
   */
  contextToAppId: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';
    return `CUBEJS_APP_${databaseId}`;
  },

  /**
   * Isolate the query orchestrator (and driver cache) per database.
   * Without this, all tenants share the same orchestrator and cached
   * driver instances, causing queries to hit the wrong database.
   */
  contextToOrchestratorId: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';
    return `CUBEJS_APP_${databaseId}`;
  },

  /**
   * Dynamic repository for per-database schema files
   * Each database has its own cube model at data/databases/{id}/cube/model
   */
  repositoryFactory: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';

    console.log(`[repositoryFactory] ========================================`);
    console.log(`[repositoryFactory] Request for databaseId: "${databaseId}"`);

    // Use relative path from /cube/conf (Cube.js working directory)
    // DATA_DIR in container is /cube/data, which is ../data relative to /cube/conf
    const relativeDataDir = '../data';
    const dbModelPath = path.join(relativeDataDir, 'databases', databaseId, 'cube', 'model');

    // For checking existence, we need the absolute path
    const absolutePath = path.resolve('/cube/conf', dbModelPath);

    console.log(`[repositoryFactory] Looking for schema at: ${absolutePath}`);

    // If database-specific path exists, use FileRepository for it
    if (fs.existsSync(absolutePath)) {
      console.log(`[repositoryFactory] Found schema directory, using FileRepository`);
      const { FileRepository } = require('@cubejs-backend/server-core');
      return new FileRepository(dbModelPath);
    }

    // Fall back to default cube model path
    console.warn(`[repositoryFactory] WARNING: Schema path not found: ${absolutePath}`);
    console.warn(`[repositoryFactory] Falling back to default repository`);
    return undefined; // Use default repository
  },

  /**
   * Scheduled refresh contexts for all active databases
   * TODO: In production, this should read from the database registry
   */
  scheduledRefreshContexts: () => {
    const contexts = [{}]; // Default context

    // Add contexts for other databases if needed
    // This would typically be populated from the database registry

    return contexts;
  },

  // Allow all origins in development
  http: {
    cors: {
      origin: '*',
    },
  },

  /**
   * Pre-aggregations configuration
   */
  preAggregationsSchema: ({ securityContext }) => {
    const databaseId = securityContext?.databaseId || 'default';
    return `pre_aggregations_${databaseId}`;
  },

  /**
   * Query rewrite for tenant isolation
   * Can be used to add automatic filters based on tenant
   */
  queryRewrite: (query, { securityContext }) => {
    // No modifications needed for now, but this could be used
    // to enforce row-level security based on databaseId
    return query;
  },
};
